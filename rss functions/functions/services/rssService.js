// services/rssService.js
const {throttleRequests} = require("../utils/throttle");
const feedUrls = require("../feedUrls");
const {categorizeArticleRuleBased, analyzeSentiment, analyzeEntities} = require("../utils/analysis");
const {getUniqueKey} = require("../utils/helpers");
const admin = require("../config/firebase");
const db = admin.firestore();

/**
 * Processes RSS feeds: fetches feeds, processes items, and stores them in Firestore.
 * Duplicate checking is handled by using a unique key (generated by getUniqueKey) as the document ID.
 * Firestore's upsert behavior (using {merge: true}) ensures that if a document already exists,
 * it will be updated rather than creating a duplicate.
 * @return {Promise<Object>} Result message and count.
 */
async function fetchAndStoreRssFeeds() {
  const feeds = await throttleRequests(feedUrls);
  let batch = db.batch();
  const MAX_BATCH_SIZE = 500;
  let operationCount = 0;

  for (const feed of feeds) {
    if (!feed || !feed.items) continue;
    const processedItems = await Promise.all(
        feed.items.map(async (item) => {
          const contentForAnalysis =
          item["content:encoded"] || item.content || item.description || item.contentSnippet || "";
          const category = categorizeArticleRuleBased(contentForAnalysis);
          const sentiment = analyzeSentiment(contentForAnalysis);
          let entities = {};
          try {
            entities = await analyzeEntities(contentForAnalysis);
          } catch (e) {
            console.error("Entity analysis failed for article:", item.title, e);
          }
          let geoLocation = null;
          if (item["geo:lat"] && item["geo:long"]) {
            geoLocation = {lat: parseFloat(item["geo:lat"]), lng: parseFloat(item["geo:long"])};
          } else if (entities.places && entities.places.length > 0) {
            geoLocation = entities.places[0];
          }
          let imageUrl = null;
          if (item.enclosure && item.enclosure.url) {
            imageUrl = item.enclosure.url;
          }
          // Duplicate checking: using the unique key as the Firestore doc ID prevents duplicate entries.
          const uniqueKey = getUniqueKey(item.title, item.link);
          return {
            uniqueKey,
            data: {
              title: item.title,
              link: item.link,
              pubDate: item.pubDate || null,
              source: feed.title,
              category,
              sentiment,
              entities,
              location: geoLocation,
              description: contentForAnalysis,
              imageUrl,
              createdAt: admin.firestore.FieldValue.serverTimestamp(),
            },
          };
        }),
    );
    for (const {uniqueKey, data} of processedItems) {
      const collectionRef = db.collection("rss_articles").doc(data.category).collection("articles");
      const docRef = collectionRef.doc(uniqueKey);

      // Upsert operation: If a document with uniqueKey already exists, this will update it (preventing duplicates)
      batch.set(docRef, data, {merge: true});
      operationCount++;
      if (operationCount >= MAX_BATCH_SIZE) {
        await batch.commit();
        console.log("Committed a batch of RSS articles, count:", operationCount);
        batch = db.batch();
        operationCount = 0;
      }
    }
  }
  if (operationCount > 0) {
    await batch.commit();
    console.log("Final batch commit executed for RSS articles, remaining count:", operationCount);
  }
  return {message: "RSS feeds stored successfully", count: feeds.length};
}

module.exports = {fetchAndStoreRssFeeds};
